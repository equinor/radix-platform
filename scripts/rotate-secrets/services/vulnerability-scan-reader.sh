#!/usr/bin/env bash
red=$'\e[1;31m'
grn=$'\e[1;32m'
yel=$'\e[1;33m'
normal=$(tput sgr0)

#######################################################################################
### PURPOSE
###

# Rotates secret for radix-vulnerability-scanner's reader user in a radix cluster

#######################################################################################
### PRECONDITIONS
###

# - AKS cluster is available
# - User has role cluster-admin

#######################################################################################
### INPUTS
###

# Required:
# - RADIX_ZONE_ENV               : Path to *.env file
# - CLUSTER_NAME                 : Ex: "test-2", "weekly-93"

# Optional:
# - UPDATE_SECRETS               : Rotate expired secrets. Defaults to false.
# - USER_PROMPT                  : Is human interaction required to run script? true/false. Default is true.

#######################################################################################
### HOW TO USE
###

# NORMAL
# RADIX_ZONE_ENV=../../radix-zone/radix_zone_dev.env CLUSTER_NAME=weekly-07 UPDATE_SECRETS=false ./vulnerability-scan-reader.sh

#######################################################################################
### Check dependencies
###

echo ""
printf "Start rotating secrets for radix-vulnerability-scanner reader... \n"

printf "Loading dependencies... "
source "${RADIX_ZONE_ENV:-'!!!! No RADIX_ZONE_ENV Provided !!!!'}"
source "${RADIX_PLATFORM_REPOSITORY_PATH}/scripts/utility/util.sh"
source "${RADIX_PLATFORM_REPOSITORY_PATH}/scripts/azure-sql/lib_firewall.sh"
source "${RADIX_PLATFORM_REPOSITORY_PATH}/scripts/rotate-secrets/lib_keyvault.sh"
source "${RADIX_PLATFORM_REPOSITORY_PATH}/scripts/azure-sql/lib_security.sh"
source "${RADIX_PLATFORM_REPOSITORY_PATH}/scripts/utility/lib_dependencies.sh"
printf "Done.\n"

assert_cli_tools || exit 1
has_env_name "CLUSTER_NAME" || exit 1
prepare_azure_session || exit 1
setup_cluster_access  "$AZ_RESOURCE_GROUP_CLUSTERS" "$CLUSTER_NAME" ||
  { echo "ERROR: Unable to connect to cluster" >&2; exit 1; }

USER_PROMPT=${USER_PROMPT:=true}
UPDATE_SECRETS=${UPDATE_SECRETS:=false}

KEY_VAULT="radix-keyv-${RADIX_ZONE}"
if [[ "${RADIX_ZONE}" == "prod" ]]; then
  KEY_VAULT="radix-keyv-platform"
fi;

echo -e ""
echo -e "Bootstrap Radix Vulnerability Scanner with the following configuration:"
echo -e ""
echo -e "   > WHERE:"
echo -e "   ------------------------------------------------------------------"
echo -e "   -  RADIX_ZONE                           : $RADIX_ZONE"
echo -e "   -  CLUSTER_NAME                         : $CLUSTER_NAME"
echo -e "   -  KEY_VAULT                            : $KEY_VAULT"
echo -e "   -  VULNERABILITY_SCAN_SQL_SERVER_NAME   : $VULNERABILITY_SCAN_SQL_SERVER_NAME"
echo -e "   -  VULNERABILITY_SCAN_SQL_DATABASE_NAME : $VULNERABILITY_SCAN_SQL_DATABASE_NAME"
echo -e ""
echo -e "   > WHAT:"
echo -e "   ------------------------------------------------------------------"
echo -e "   -  UPDATE_SECRETS                       :  $UPDATE_SECRETS"
echo -e "   -  SECRET                               :  $KV_SECRET_VULNERABILITY_SCAN_DB_API"
echo -e ""
echo -e "   > WHO:"
echo -e "   -------------------------------------------------------------------"
echo -e "   -  AZ_SUBSCRIPTION                      : $(az account show --query name -otsv)"
echo -e "   -  AZ_USER                              : $(az account show --query user.name -o tsv)"
echo -e ""

echo ""

user_prompt_continue || exit 1


#######################################################################################
### Control Secret
###

secretShouldUpdate=false

secretExists=$(keyvault_secret_exist ${KEY_VAULT} ${KV_SECRET_VULNERABILITY_SCAN_DB_API})

if [ $secretExists -eq 1 ]; then
  secretShouldUpdate=true
  printf "%sSecret %s missing, should be created%s\n" ${yel} ${KV_SECRET_VULNERABILITY_SCAN_DB_API} ${normal}
elif [ $secretExists -eq 0 ]; then
  expiry=$(keyvault_secret_ttl_days ${KEY_VAULT} ${KV_SECRET_VULNERABILITY_SCAN_DB_API})
  if [ $expiry -le 31 ]; then
    secretShouldUpdate=true
    printf "%sSecret %s expires in %s days, should be updated %s \n" ${yel} ${KV_SECRET_VULNERABILITY_SCAN_DB_API} ${expiry} ${normal}
  fi;
else
  printf "Unknown response from secret exists: %s\n" $secretExists
  exit 2
fi;


if [ $secretShouldUpdate == "false" ]; then
  printf "No outdated secrets. Secret expires in %s%s%s days\n" $grn "${expiry}" $normal
  exit 0
fi;

if [ $UPDATE_SECRETS != "true" ]; then
  printf "Secrets should be updated Run with UPDATE_SECRETS=true to update.\n"
  exit 1
fi;

printf "Generating password... "
SCANNER_SQL_PASSWORD=$(head -c 32 /dev/urandom | base64 --wrap 0) ||
    { echo "ERROR: Could not generate password." >&2; exit 1; }
printf "Done.\n"

printf "Saving password to %s... " "${KEY_VAULT}"
keyvault_secret_save "${KEY_VAULT}" "${KV_SECRET_VULNERABILITY_SCAN_DB_API}" "${SCANNER_SQL_PASSWORD}" ||
    { echo "ERROR: Could not save password." >&2; exit 1; }
printf "Done.\n"

printf "Whitelist IP in firewall rule for SQL Server... "
whitelistRuleName="ClientIpAddress_$(date +%Y%m%d%H%M%S)"

add_local_computer_sql_firewall_rule \
    "${VULNERABILITY_SCAN_SQL_SERVER_NAME}" \
    "${AZ_RESOURCE_GROUP_VULNERABILITY_SCAN_SQL}" \
    "${whitelistRuleName}" \
    || { echo "ERROR: Could not add IP to firewall." >&2; exit 1; }
printf "Done.\n"

printf "Creating/updating SQL user for Radix Vulnerability Scanner... "
create_or_update_sql_user \
    "${VULNERABILITY_SCAN_SQL_SERVER_FQDN}" \
    "${VULNERABILITY_SCAN_SQL_DATABASE_NAME}" \
    "${VULNERABILITY_SCAN_SQL_SCANNER_USER}" \
    "${SCANNER_SQL_PASSWORD}" \
    "radixreader" ||
    { echo "ERROR: Could not update password in database." >&2; exit 1; }
printf "Done.\n"

printf "Remove IP in firewall rule for SQL Server... "
delete_sql_firewall_rule \
    $VULNERABILITY_SCAN_SQL_SERVER_NAME \
    $AZ_RESOURCE_GROUP_VULNERABILITY_SCAN_SQL \
    $whitelistRuleName \
    || exit
printf "Done.\n"


VULNERABILITY_SCANNER_API_SECRET_NAME_QA=$(kubectl get secret --namespace "radix-vulnerability-scanner-api-qa" --selector radix-component="server" -ojson | jq -r .items[0].metadata.name)
VULNERABILITY_SCANNER_API_SECRET_NAME_PROD=$(kubectl get secret --namespace "radix-vulnerability-scanner-api-prod" --selector radix-component="server" -ojson | jq -r .items[0].metadata.name)

kubectl patch secret VULNERABILITY_SCANNER_API_SECRET_NAME_QA --type='json' -p="[{\"op\" : \"replace\" ,\"path\" : \"/data/SQL_PASSWORD\" ,\"value\" : \"$(echo $SCANNER_SQL_PASSWORD | base64)\"}]"
kubectl patch secret VULNERABILITY_SCANNER_API_SECRET_NAME_PROD --type='json' -p="[{\"op\" : \"replace\" ,\"path\" : \"/data/SQL_PASSWORD\" ,\"value\" : \"$(echo $SCANNER_SQL_PASSWORD | base64)\"}]"

kubectl rollout restart deployment -n radix-vulnerability-scanner-api-qa
kubectl rollout restart deployment -n radix-vulnerability-scanner-api-prod
